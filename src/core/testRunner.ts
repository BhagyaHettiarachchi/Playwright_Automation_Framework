import { Page } from '@playwright/test';
import { TestGenerator } from './testGenerator';
import { SelfHealingManager } from './selfHealing';
import { VisualRegressionManager } from './visualRegression';
import { TestCase } from '../models/TestCase';
import { TestResult } from '../models/TestResult';
import fs from 'fs/promises';
import path from 'path';

export class AITestRunner {
  private testGenerator: TestGenerator;
  private selfHealing: SelfHealingManager;
  private visualRegression: VisualRegressionManager;
  private results: TestResult[] = [];

  constructor() {
    this.testGenerator = new TestGenerator();
    this.selfHealing = new SelfHealingManager();
    this.visualRegression = new VisualRegressionManager();
  }

  async runTestCaseWithAI(
    page: Page,
    testCase: TestCase
  ): Promise<TestResult> {
    const startTime = Date.now();
    const result: TestResult = {
      testCaseId: testCase.id,
      status: 'PASSED',
      executionTime: 0,
      timestamp: new Date(),
      errors: [],
      screenshots: [],
      selfHealingApplied: false,
    };

    try {
      console.log(`\nðŸ§ª Running test: ${testCase.title}`);
      console.log(`   Generated by: ${testCase.generatedBy}`);

      for (const [index, step] of testCase.steps.entries()) {
        console.log(`\n   Step ${index + 1}: ${step.description}`);
        
        try {
          await this.executeStepWithHealing(page, step, result);
          
          if (step.action === 'click' || step.action === 'navigate') {
            const visualDiff = await this.visualRegression.captureAndCompare(
              page,
              `${testCase.id}-step-${index}`,
              { fullPage: true }
            );
            
            if (visualDiff.hasDifference) {
              result.errors = result.errors || [];
              result.errors.push(
                `Visual regression detected at step ${index + 1}: ${visualDiff.diffPercentage.toFixed(2)}% difference`
              );
            }
          }
          
        } catch (error: any) {
          result.status = 'FAILED';
          result.errors = result.errors || [];
          result.errors.push(`Step ${index + 1} failed: ${error.message}`);
          
          const screenshotPath = path.join(
            './screenshots/failures',
            `${testCase.id}-step-${index}-${Date.now()}.png`
          );
          await fs.mkdir(path.dirname(screenshotPath), { recursive: true });
          await page.screenshot({ path: screenshotPath, fullPage: true });
          result.screenshots?.push(screenshotPath);
          
          throw error;
        }
      }

      for (const expectedResult of testCase.expectedResults) {
        await this.verifyExpectedResult(page, expectedResult);
      }

      result.status = 'PASSED';
      console.log(`\n   âœ“ Test passed: ${testCase.title}`);

    } catch (error: any) {
      result.status = 'FAILED';
      console.log(`\n   âœ— Test failed: ${testCase.title}`);
      console.log(`   Error: ${error.message}`);
    }

    result.executionTime = Date.now() - startTime;
    this.results.push(result);
    
    return result;
  }

  private async executeStepWithHealing(
    page: Page,
    step: any,
    result: TestResult
  ): Promise<void> {
    const { action, selector, value, description } = step;

    const { locator, healed, newSelector } = await this.selfHealing.findElementWithHealing(
      page,
      selector,
      description
    );

    if (healed) {
      result.selfHealingApplied = true;
      result.healingDetails = {
        originalSelector: selector,
        newSelector: newSelector || selector,
        reason: `Element located using self-healing mechanism`,
      };
      console.log(`   ðŸ”§ Self-healing applied for selector: ${selector}`);
    }

    switch (action.toLowerCase()) {
      case 'navigate':
        await page.goto(value || selector);
        break;
      
      case 'click':
        await locator.click();
        break;
      
      case 'fill':
        await locator.fill(value || '');
        break;
      
      case 'select':
        await locator.selectOption(value || '');
        break;
      
      case 'check':
        await locator.check();
        break;
      
      case 'press':
        await locator.press(value || 'Enter');
        break;
      
      case 'wait':
        await page.waitForTimeout(parseInt(value || '1000'));
        break;
      
      default:
        throw new Error(`Unknown action: ${action}`);
    }

    await page.waitForTimeout(500);
  }

  private async verifyExpectedResult(
    page: Page,
    expectedResult: string
  ): Promise<void> {
    if (expectedResult.includes('visible')) {
      const selector = expectedResult.match(/['"]([^'"]+)['"]/)?.[1];
      if (selector) {
        await page.locator(selector).waitFor({ state: 'visible' });
      }
    }
  }

  async generateComprehensiveReport(): Promise<string> {
    const reportPath = './reports/comprehensive-report.html';
    
    const totalTests = this.results.length;
    const passed = this.results.filter(r => r.status === 'PASSED').length;
    const failed = this.results.filter(r => r.status === 'FAILED').length;
    const healingApplied = this.results.filter(r => r.selfHealingApplied).length;
    
    const avgExecutionTime =
      this.results.reduce((sum, r) => sum + r.executionTime, 0) / totalTests;

    const healingStats = await this.selfHealing.getHealingStats();

    const html = `
<!DOCTYPE html>
<html>
<head>
  <title>AI-Augmented Test Report</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
    .container { max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; }
    h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
    .summary { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin: 20px 0; }
    .stat-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; text-align: center; }
    .stat-card.success { background: linear-gradient(135deg, #4caf50 0%, #45a049 100%); }
    .stat-card.failure { background: linear-gradient(135deg, #f44336 0%, #e53935 100%); }
    .stat-card.healing { background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%); }
    .stat-value { font-size: 2.5em; font-weight: bold; }
    .stat-label { font-size: 0.9em; opacity: 0.9; margin-top: 5px; }
    .test-result { border: 1px solid #ddd; margin: 15px 0; padding: 20px; border-radius: 8px; }
    .test-result.passed { border-left: 5px solid #4caf50; background: #f1f8f4; }
    .test-result.failed { border-left: 5px solid #f44336; background: #fef1f0; }
  </style>
</head>
<body>
  <div class="container">
    <h1>ðŸ¤– AI-Augmented Test Execution Report</h1>
    
    <div class="summary">
      <div class="stat-card">
        <div class="stat-value">${totalTests}</div>
        <div class="stat-label">Total Tests</div>
      </div>
      <div class="stat-card success">
        <div class="stat-value">${passed}</div>
        <div class="stat-label">Passed</div>
      </div>
      <div class="stat-card failure">
        <div class="stat-value">${failed}</div>
        <div class="stat-label">Failed</div>
      </div>
      <div class="stat-card healing">
        <div class="stat-value">${healingApplied}</div>
        <div class="stat-label">Self-Healing Applied</div>
      </div>
    </div>

    <h2>ðŸ“Š Performance Metrics</h2>
    <p>Average Execution Time: ${(avgExecutionTime / 1000).toFixed(2)}s</p>
    <p>Total Healing Operations: ${healingStats.totalHealings}</p>

    <h2>ðŸ§ª Test Results</h2>
    ${this.results.map(result => `
      <div class="test-result ${result.status.toLowerCase()}">
        <h3>${result.status === 'PASSED' ? 'âœ“' : 'âœ—'} Test Case: ${result.testCaseId}</h3>
        <p><strong>Execution Time:</strong> ${(result.executionTime / 1000).toFixed(2)}s</p>
        ${result.selfHealingApplied ? '<p>ðŸ”§ Self-Healing Applied</p>' : ''}
        ${result.errors && result.errors.length > 0 ? 
          `<div><strong>Errors:</strong><br/>${result.errors.join('<br/>')}</div>` : ''}
      </div>
    `).join('')}
  </div>
</body>
</html>
    `;

    await fs.mkdir(path.dirname(reportPath), { recursive: true });
    await fs.writeFile(reportPath, html);
    
    console.log(`\nðŸ“Š Report generated: ${reportPath}`);
    return reportPath;
  }

  getResults(): TestResult[] {
    return this.results;
  }

  getSummary() {
    const total = this.results.length;
    const passed = this.results.filter(r => r.status === 'PASSED').length;
    const failed = this.results.filter(r => r.status === 'FAILED').length;
    const healingApplied = this.results.filter(r => r.selfHealingApplied).length;

    return {
      total,
      passed,
      failed,
      passRate: (passed / total) * 100,
      healingRate: (healingApplied / total) * 100,
    };
  }
}